<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="utf-8" />
  <title>Chat Window</title>
  <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline'; connect-src *; img-src data:;">
  <style>
    :root {
      --bg-color: #1a1a1a;
      --text-color: #e0e0e0;
      --primary-color: #007bff;
      --user-msg-bg: #004a99;
      --assistant-msg-bg: #333333;
      --input-bg: #252525;
      --border-color: #444444;
      --status-color: #888888;
      --error-color: #ff4d4d;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      background: var(--bg-color);
      color: var(--text-color);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      overflow: hidden;
    }

    .chat-container {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    .chat-header {
      padding: 12px 16px;
      background: var(--input-bg);
      border-bottom: 1px solid var(--border-color);
      font-size: 16px;
      font-weight: 600;
      flex-shrink: 0;
      text-align: center;
    }

    .chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .message {
      display: flex;
      flex-direction: column;
      max-width: 85%;
      word-wrap: break-word;
    }

    .message .content {
      padding: 10px 14px;
      border-radius: 18px;
      white-space: pre-wrap;
      line-height: 1.5;
      position: relative; /* ‰∏∫ÂÜÖÈÉ®ÁªùÂØπÂÆö‰ΩçÁöÑÊåâÈíÆÊèê‰æõÂÆπÂô® */
      cursor: pointer; /* ÊèêÁ§∫Êï¥‰∏™ÂÜÖÂÆπÂå∫ÂüüÈÉΩÂèØÁÇπÂáª */
      transition: max-height 0.28s cubic-bezier(.2,.9,.2,1), transform 0.18s ease-out;
      will-change: max-height;
    }
    
    .message .content .message-text {
        margin-bottom: 8px;
    }

    .message .content .message-images {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
    }

  .message .content .message-images img {
    max-width: 360px;
    max-height: 360px;
    border-radius: 8px;
    object-fit: cover;
    cursor: pointer;
  }

    /* Collapsible message support */
  /* When collapsed, limit height and show a soft gradient mask */
  .message.collapsed .content { max-height: 60px; overflow: hidden; }
  .message.collapsed .content .message-images { display: none; }
  .message.collapsed .content .message-text { display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; }
  .message.collapsed .content::after {
    content: '';
    position: absolute;
    left: 0;
    right: 0;
    bottom: 0;
    height: 36px;
    pointer-events: none;
    background: linear-gradient(to bottom, rgba(0,0,0,0), var(--assistant-msg-bg));
  }
  .message.user.collapsed .content::after {
    background: linear-gradient(to bottom, rgba(0,0,0,0), var(--primary-color));
  }
    .message-toggle {
      position: absolute;
      bottom: 8px;
      right: 8px;
      width: 26px;
      height: 26px;
      background: rgba(0,0,0,0.28);
      border: none;
      color: rgba(255,255,255,0.9);
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      line-height: 1;
      padding: 0;
      transition: transform 0.28s ease, background 0.18s ease;
      z-index: 20;
    }
    .message.collapsed .message-toggle { transform: rotate(-90deg) scale(1); }
    .message-toggle:hover { transform: scale(1.06); background: rgba(0,0,0,0.42); }
    .message.collapsed .message-toggle:hover { transform: rotate(-90deg) scale(1.06); }

    .message.user {
      align-self: flex-end;
      align-items: flex-end;
    }

    .message.user .content {
      background: var(--primary-color);
      color: #ffffff;
      border-bottom-right-radius: 4px;
    }

    .message.assistant {
      align-self: flex-start;
      align-items: flex-start;
    }

    .message.assistant .content {
      background: var(--assistant-msg-bg);
      border-bottom-left-radius: 4px;
    }

    .typing-indicator span {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--status-color);
      margin: 0 2px;
      animation: bounce 1.4s infinite ease-in-out both;
    }

    .typing-indicator span:nth-child(1) { animation-delay: -0.32s; }
    .typing-indicator span:nth-child(2) { animation-delay: -0.16s; }
    @keyframes bounce {
      0%, 80%, 100% { transform: scale(0); }
      40% { transform: scale(1.0); }
    }

    .chat-input-area {
      padding: 12px;
      border-top: 1px solid var(--border-color);
      background: var(--input-bg);
      flex-shrink: 0;
    }

    .input-form {
      display: flex;
      align-items: flex-end;
      gap: 10px;
    }

    textarea {
      flex: 1;
      padding: 10px;
      border-radius: 6px;
      border: 1px solid var(--border-color);
      background: var(--bg-color);
      color: var(--text-color);
      resize: none;
      font-size: 14px;
      line-height: 1.4;
      max-height: 150px;
      overflow-y: auto;
    }

    textarea:focus {
      outline: none;
      border-color: var(--primary-color);
    }
    
  /* Image preview styles */
    #image-preview-container {
      display: flex;
      gap: 10px;
      padding: 0 0 10px 0;
      flex-wrap: wrap;
    }

    .img-preview-wrapper {
        position: relative;
    }
    
    .img-preview-wrapper img {
        width: 70px;
        height: 70px;
        border-radius: 8px;
        object-fit: cover;
    }

    .remove-img-btn {
        position: absolute;
        top: -5px;
        right: -5px;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        border: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        line-height: 1;
        padding: 0;
    }

    .icon-button {
      padding: 8px;
      width: 40px;
      height: 40px;
      border-radius: 6px;
      border: none;
      background: var(--assistant-msg-bg);
      color: #fff;
      font-size: 20px;
      cursor: pointer;
      transition: background-color 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .icon-button:hover { background: #444; }

    #ai-send {
      height: 40px;
      padding: 0 18px;
      border: none;
      border-radius: 999px;
      background: var(--primary-color);
      color: #ffffff;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      font-size: 14px;
      font-weight: 600;
      letter-spacing: 0.015em;
      cursor: pointer;
      box-shadow: 0 10px 24px rgba(0, 123, 255, 0.25);
      transition: transform 0.18s ease, box-shadow 0.18s ease, background 0.18s ease;
      min-width: 110px;
    }

    #ai-send:hover:not(:disabled) {
      background: #1c86ff;
      box-shadow: 0 12px 26px rgba(28, 134, 255, 0.35);
      transform: translateY(-1px);
    }

    #ai-send:active:not(:disabled) {
      transform: translateY(0);
      box-shadow: 0 6px 16px rgba(0, 90, 210, 0.35);
    }

    #ai-send:focus-visible {
      outline: 2px solid rgba(255, 255, 255, 0.6);
      outline-offset: 2px;
    }

    #ai-send:disabled {
      background: #3a3a3a;
      color: rgba(255, 255, 255, 0.6);
      box-shadow: none;
      cursor: not-allowed;
      opacity: 0.85;
    }

    #ai-send .send-icon {
      font-size: 13px;
      line-height: 1;
      display: flex;
      align-items: center;
    }

    #ai-send .send-label {
      white-space: nowrap;
    }
  /* --- end styles --- */

    button:disabled { background: #555; cursor: not-allowed; }

    .status-bar {
      padding: 6px 12px;
      color: var(--status-color);
      font-size: 12px;
      text-align: center;
      background: rgba(0,0,0,0.1);
    }
    .status-bar.error {
      color: white;
      background-color: var(--error-color);
    }
  </style>
</head>

<body>
  <div class="chat-container">
    <div class="chat-messages" id="chat-messages"></div>
    <div class="chat-input-area">
      <div id="image-preview-container"></div>
      <form id="input-form" class="input-form">
    <input type="file" id="image-input" accept="image/*" multiple style="display: none;" />
  <!-- attach image button -->
  <button type="button" id="attach-file-btn" class="icon-button" data-i18n-title="chat.attachImage" data-i18n-aria-label="chat.attachImage" title="Attach image" aria-label="Attach image">üìé</button>
        
  <textarea id="ai-input" placeholder="Type a message... (Shift+Enter for newline)" rows="1" data-i18n-placeholder="chat.placeholder"></textarea>
  <button id="ai-send" type="submit" data-i18n="chat.send" data-i18n-aria-label="chat.send" aria-label="Send">
  <span class="send-icon" aria-hidden="true">&#10148;</span>
    <span class="send-label" data-i18n="chat.send">Send</span>
  </button>
      </form>
    </div>
  <div class="status-bar" id="status-bar" data-i18n="status.ready">Ready</div>
  </div>

  <script>
  // Configuration defaults for the chat window
    // Obtain injected config via IPC invoke (preferred). Older versions may not
    // support this; in that case, chatConfig will remain defaults.

    const defaultConfig = {
      // title is intentionally not used from injected config. The page will display
      // a fixed title 'Chat Window' and append the provided llmKey in parentheses.
      title: 'Chat Window',
      api: {
        type: 'ollama',
        model: '',
        baseUrl: '',
        apiKey: ''
      },
      initialPrompt: '',
  initialImages: [],
      llmParams: {
        temperature: 0.7,
        top_p: 0.95,
        top_k: 0.9,
        context_window: 32768,
        max_tokens: 32768,
        presence_penalty: 1.0
      }
    };

  // Fetch injected config during initialization via aiAPI.getConfig();
  const chatConfig = Object.assign({}, defaultConfig);
  // Guard to avoid applying injected config twice (from getConfig + pushed injected-config)
  let _injectedConfigApplied = false;

  // Lightweight translation helper with fallback support
  const translate = (key, fallback = '', values) => {
    if (window.i18nDom && typeof window.i18nDom.t === 'function') {
      const result = window.i18nDom.t(key, values);
      if (result != null && result !== '') {
        return result;
      }
    }
    return fallback;
  };

    // -------------------------------------------------------------
    // 2. ËÅäÂ§©Á™óÂè£ÂäüËÉΩÂÆûÁé∞
    // -------------------------------------------------------------
 
  // DOM Elements (note: internal title element removed; native window title used)
  const messagesEl = document.getElementById('chat-messages');
      const formEl = document.getElementById('input-form');
      const inputEl = document.getElementById('ai-input');
      const sendBtn = document.getElementById('ai-send');
    const sendLabelEl = sendBtn ? sendBtn.querySelector('.send-label') : null;
      const statusBar = document.getElementById('status-bar');
      // Êñ∞Â¢û DOM ÂÖÉÁ¥†
      const attachBtn = document.getElementById('attach-file-btn');
      const imageInput = document.getElementById('image-input');
      const imagePreviewContainer = document.getElementById('image-preview-container');
      
      // Conversation history and state
      let conversationHistory = [];
      let isGenerating = false;
      // Êñ∞Â¢û: Áî®‰∫éÂ≠òÂÇ®ÂæÖÂèëÈÄÅÂõæÁâáÁöÑÊï∞ÁªÑ
      let stagedImages = []; // Â≠òÂÇ® { id, base64Full, base64Raw, mimeType }

      const IMAGE_MIME_FALLBACK = 'image/png';

      function extractMimeTypeFromDataUrl(dataUrl) {
        const match = /^data:([^;]+);base64,/i.exec(dataUrl || '');
        return match ? match[1] : '';
      }

      function normalizeImageForHistory(image) {
        if (!image) return null;
        if (typeof image === 'string') {
          return image ? { base64Raw: image, mimeType: '' } : null;
        }
        const base64Raw = image.base64Raw || '';
        if (!base64Raw) return null;
        const mimeType = image.mimeType || extractMimeTypeFromDataUrl(image.base64Full) || '';
        return { base64Raw, mimeType };
      }

      function ensureUiImageShape(image) {
        if (!image) return null;
        if (typeof image === 'string') {
          const dataUrl = image.startsWith('data:') ? image : `data:${IMAGE_MIME_FALLBACK};base64,${image}`;
          return { base64Full: dataUrl, base64Raw: image.replace(/^data:[^,]+,/, ''), mimeType: extractMimeTypeFromDataUrl(dataUrl) || '' };
        }
        const base64Full = image.base64Full || (image.base64Raw ? `data:${image.mimeType || IMAGE_MIME_FALLBACK};base64,${image.base64Raw}` : '');
        if (!base64Full) return null;
        const mimeType = image.mimeType || extractMimeTypeFromDataUrl(base64Full) || '';
        return {
          base64Full,
          base64Raw: image.base64Raw || base64Full.replace(/^data:[^,]+,/, ''),
          mimeType
        };
      }
      
      // --- Initialization ---
      function initializeChat() {
  // Native window title is used (set by main process). No internal title element to render.
        if (sendLabelEl) {
          const localized = translate('chat.send', 'Send');
          if (localized) {
            sendLabelEl.textContent = localized;
            sendBtn.setAttribute('title', localized);
            sendBtn.setAttribute('aria-label', localized);
          }
        }

        inputEl.addEventListener('input', autoResizeTextarea);
        formEl.addEventListener('submit', handleFormSubmit);
        
        // Êñ∞Â¢û: ÊåâÈíÆ‰∫ã‰ª∂ÁõëÂê¨
        attachBtn.addEventListener('click', () => imageInput.click());
        imageInput.addEventListener('change', handleImageSelection);

        inputEl.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                handleFormSubmit(e);
            }
        });

        // Attempt to fetch injected config from main process via IPC
        (async () => {
          try {
            if (window.aiAPI && typeof window.aiAPI.getConfig === 'function') {
              const injected = await window.aiAPI.getConfig();
              if (injected && typeof injected === 'object') {
                // Merge injected over defaults (shallow)
                if (injected.api) injected.api = Object.assign({}, defaultConfig.api, injected.api);
                if (injected.llmParams) injected.llmParams = Object.assign({}, defaultConfig.llmParams, injected.llmParams);
                Object.assign(chatConfig, injected);
                if (injected.api) chatConfig.api = injected.api;
                if (injected.llmParams) chatConfig.llmParams = injected.llmParams;
              }
            }
          } catch (e) {
            // ignore errors fetching config; continue with defaults
          }

          // If initialPrompt or initialImages are present after merge, apply them atomically
          const hasInitialPrompt = chatConfig.initialPrompt && chatConfig.initialPrompt.trim() !== '';
          const hasInitialImages = chatConfig.initialImages && Array.isArray(chatConfig.initialImages) && chatConfig.initialImages.length > 0;

          if (!_injectedConfigApplied && (hasInitialPrompt || hasInitialImages)) {
              // prepare UI message (with full base64s)
            const uiImages = hasInitialImages ? chatConfig.initialImages.map(ensureUiImageShape).filter(Boolean) : [];
            const uiMessage = {
              role: 'user',
              content: chatConfig.initialPrompt || '',
              images: uiImages
            };

            // prepare API message (raw base64 only)
            const apiMessage = {
              role: 'user',
              content: chatConfig.initialPrompt || '',
              images: uiImages.map(normalizeImageForHistory).filter(Boolean)
            };

            addMessageToUI('user', uiMessage);
            conversationHistory.push(apiMessage);
            fetchAIResponse();

            // mark applied so a pushed injected-config won't re-apply
            _injectedConfigApplied = true;
          }
        })();
      }

      // Listener for injected config pushed by main process
      try {
        if (window.aiAPI && typeof window.aiAPI.onInjectedConfig === 'function') {
          window.aiAPI.onInjectedConfig((cfg) => {
            try {
              if (_injectedConfigApplied) return;
              applyInjectedConfig(cfg);
              _injectedConfigApplied = true;
            } catch (e) { /* ignore */ }
          });
        }
      } catch (e) { /* ignore */ }


    // Apply a config object received via IPC at any time. This merges into chatConfig
    // and triggers initial prompt/images if present.
    function applyInjectedConfig(cfg) {
      // merge and apply injected config; avoid verbose logging here

      if (!cfg || typeof cfg !== 'object') return;
      // Merge into chatConfig (shallow)
      try {
        // Do not accept injected title; prefer fixed 'Chat Window' and use llmKey.
        if (cfg.llmKey) chatConfig.llmKey = cfg.llmKey;
        if (cfg.api) chatConfig.api = Object.assign({}, chatConfig.api, cfg.api);
        if (cfg.llmParams) chatConfig.llmParams = Object.assign({}, chatConfig.llmParams, cfg.llmParams);
        // override initialPrompt if provided
        if (typeof cfg.initialPrompt !== 'undefined') chatConfig.initialPrompt = cfg.initialPrompt;
        // merge initialImages if provided
        if (Array.isArray(cfg.initialImages)) chatConfig.initialImages = cfg.initialImages.slice();
        try { console.log('ChatPage: applyInjectedConfig: initialPromptLen=', String(chatConfig.initialPrompt || '').length, 'initialImages=', (chatConfig.initialImages||[]).length); } catch (e) {}
      } catch (e) { /* ignore merge errors */ }

      // If the UI isn't yet initialized, do nothing: initializeChat will pick this up.
      // Otherwise, if already initialized, immediately render and/or fetch.
      try {
  // Native window title is used (set by main process). No internal title element to update.

        const hasInitialPrompt = chatConfig.initialPrompt && chatConfig.initialPrompt.trim() !== '';
        const hasInitialImages = chatConfig.initialImages && Array.isArray(chatConfig.initialImages) && chatConfig.initialImages.length > 0;
    
        if (hasInitialPrompt || hasInitialImages) {
          const uiImages = hasInitialImages ? chatConfig.initialImages.map(ensureUiImageShape).filter(Boolean) : [];
          const uiMessage = {
            role: 'user',
            content: chatConfig.initialPrompt || '',
            images: uiImages
          };
          
          const apiMessage = {
            role: 'user',
            content: chatConfig.initialPrompt || '',
            images: uiImages.map(normalizeImageForHistory).filter(Boolean)
          };

          addMessageToUI('user', uiMessage);
          conversationHistory.push(apiMessage);
          fetchAIResponse();
        }
      } catch (e) { /* ignore UI errors */ }
    }
      // --- UI Helper Functions ---
      // ‰øÆÊîπ: addMessageToUI Áé∞Âú®Êé•Âèó‰∏Ä‰∏™Ê∂àÊÅØÂØπË±°
    function addMessageToUI(sender, message) {
      const messageWrapper = document.createElement('div');
      messageWrapper.className = `message ${sender}`;
      messageWrapper.style.position = 'relative';
          
      const contentDiv = document.createElement('div');
      contentDiv.className = 'content';

      // collapse/expand toggle
      const toggleBtn = document.createElement('button');
      toggleBtn.className = 'message-toggle';
  toggleBtn.setAttribute('data-i18n-title', 'toggle.collapseTitle');
  toggleBtn.title = translate('toggle.collapseTitle', 'Collapse/Expand');
      toggleBtn.textContent = '‚ñæ';
      // helper to toggle
      function toggleMessageCollapse(wrapper, btn) {
        if (wrapper.classList.contains('collapsed')) {
          wrapper.classList.remove('collapsed');
          btn.textContent = '‚ñæ';
        } else {
          wrapper.classList.add('collapsed');
          btn.textContent = '‚ñæ';
        }
      }
      toggleBtn.onclick = (e) => { e.stopPropagation(); toggleMessageCollapse(messageWrapper, toggleBtn); };
      messageWrapper.appendChild(toggleBtn);

          // Â¶ÇÊûúÊúâÊñáÊú¨ÂÜÖÂÆπÔºåÂàôÊ∑ªÂä†ÊñáÊú¨
      if (message.content) {
        const textEl = document.createElement('div');
        textEl.className = 'message-text';
        textEl.textContent = message.content;
        contentDiv.appendChild(textEl);
      }
          
          // Â¶ÇÊûúÊúâÂõæÁâáÔºåÂàôÊòæÁ§∫ÂõæÁâá
          if (message.images && message.images.length > 0) {
              const imagesContainer = document.createElement('div');
              imagesContainer.className = 'message-images';
              
              // Âú®Áî®Êà∑Ê∂àÊÅØ‰∏≠ÔºåÊàë‰ª¨ÊúâÂÆåÊï¥ÁöÑ data URL
              const imageSources = sender === 'user' ? message.images.map(img => img.base64Full) : [];
              
              for (const src of imageSources) {
          const imgEl = document.createElement('img');
          imgEl.src = src;
          imagesContainer.appendChild(imgEl);
        }
              contentDiv.appendChild(imagesContainer);
          }

          // make clicking the content toggle collapse as well
          contentDiv.onclick = () => { toggleMessageCollapse(messageWrapper, toggleBtn); };

          messageWrapper.appendChild(contentDiv);
          messagesEl.appendChild(messageWrapper);
          scrollToBottom();
          return messageWrapper;
      }
      
      function createAssistantMessageContainer() {
        const messageWrapper = document.createElement('div');
        messageWrapper.className = 'message assistant';
        messageWrapper.style.position = 'relative';
        // collapse toggle for assistant messages
        const toggleBtn = document.createElement('button');
        toggleBtn.className = 'message-toggle';
  toggleBtn.setAttribute('data-i18n-title', 'toggle.collapseTitle');
  toggleBtn.title = translate('toggle.collapseTitle', 'Collapse/Expand');
        toggleBtn.textContent = '‚ñæ';
        toggleBtn.onclick = (e) => { e.stopPropagation(); toggleMessageCollapse(messageWrapper, toggleBtn); };

        const contentDiv = document.createElement('div');
        contentDiv.className = 'content';
        const typingIndicator = document.createElement('div');
        typingIndicator.className = 'typing-indicator';
        typingIndicator.innerHTML = '<span></span><span></span><span></span>';
        contentDiv.appendChild(typingIndicator);
        // clicking content toggles collapse as well
        contentDiv.onclick = () => { toggleMessageCollapse(messageWrapper, toggleBtn); };
        messageWrapper.appendChild(toggleBtn);
        messageWrapper.appendChild(contentDiv);
        messagesEl.appendChild(messageWrapper);
        scrollToBottom();
        return contentDiv;
      }

      function updateAssistantMessage(container, chunk, isFinal = false) {
        if (container.querySelector('.typing-indicator')) {
            container.innerHTML = '';
        }
        container.textContent += chunk;
        if(isFinal) scrollToBottom();
      }

      function scrollToBottom() {
        messagesEl.scrollTop = messagesEl.scrollHeight;
      }

      function autoResizeTextarea() {
        inputEl.style.height = 'auto';
        inputEl.style.height = (inputEl.scrollHeight) + 'px';
      }

      function setStatus(text, isError = false) {
        statusBar.textContent = text;
        statusBar.classList.toggle('error', isError);
      }

      function toggleInput(enabled) {
        isGenerating = !enabled;
        inputEl.disabled = !enabled;
        sendBtn.disabled = !enabled;
        attachBtn.disabled = !enabled;
        if (enabled) {
          inputEl.focus();
          setStatus(translate('status.ready', 'Ready'));
        } else {
          setStatus(translate('status.generating', 'Generating...'));
        }
      }

      // --- Event Handlers ---
      function handleFormSubmit(event) {
        event.preventDefault();
        if (isGenerating) return;

        const userInput = inputEl.value.trim();
        if (!userInput && stagedImages.length === 0) return;
        const uiImages = stagedImages.map((img) => ({ ...img }));
        // ÊûÑÂª∫Ê∂àÊÅØÂØπË±°ÔºåÂåÖÂê´ÊñáÊú¨ÂíåÂõæÁâá
        const userMessage = {
          role: 'user',
          content: userInput,
          // ‰º†ÈÄíÁªô UI ÁöÑÊòØÂÆåÊï¥ÂØπË±°Ôºå‰º†ÈÄíÁªô API ÁöÑÊòØ raw base64
          images: uiImages
        };

        addMessageToUI('user', userMessage);
        
        // ÂáÜÂ§áË¶ÅÂèëÈÄÅÂà∞ API ÁöÑÂéÜÂè≤ËÆ∞ÂΩï
        const apiMessage = {
          role: 'user',
          content: userInput,
          images: uiImages.map(normalizeImageForHistory).filter(Boolean) // Âè™Âèñ raw base64 ‰∏é mime
        };
        conversationHistory.push(apiMessage);
        
        // Ê∏ÖÁêÜËæìÂÖ•Ê°ÜÂíåÊöÇÂ≠òÂå∫
        inputEl.value = '';
        autoResizeTextarea();
        clearStagedImages();
        
        fetchAIResponse();
      }
      
      // --- Êñ∞Â¢û: ÂõæÁâáÂ§ÑÁêÜÂäüËÉΩ ---
      function handleImageSelection(event) {
        const files = event.target.files;
        if (!files) return;

        for (const file of files) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const base64Full = e.target.result;
                // Ollama API ÈúÄË¶Å‰∏çÂ∏¶ "data:image/jpeg;base64," ÂâçÁºÄÁöÑÁ∫Ø base64
                const base64Raw = base64Full.split(',')[1];
                const imageId = Date.now() + Math.random(); // ÂàõÂª∫ÂîØ‰∏ÄID
        const mimeType = file.type || extractMimeTypeFromDataUrl(base64Full) || '';

        stagedImages.push({ id: imageId, base64Full, base64Raw, mimeType });
                updateImagePreviews();
            };
            reader.readAsDataURL(file);
        }
        // Ê∏ÖÁ©∫ input ÁöÑÂÄºÔºåËøôÊ†∑Áî®Êà∑ÂèØ‰ª•ÂÜçÊ¨°ÈÄâÊã©Áõ∏ÂêåÁöÑÊñá‰ª∂
        imageInput.value = '';
      }

      function updateImagePreviews() {
        imagePreviewContainer.innerHTML = '';
        stagedImages.forEach(image => {
            const wrapper = document.createElement('div');
            wrapper.className = 'img-preview-wrapper';

            const imgEl = document.createElement('img');
            imgEl.src = image.base64Full;
            
            const removeBtn = document.createElement('button');
            removeBtn.className = 'remove-img-btn';
            removeBtn.textContent = '√ó';
            removeBtn.onclick = () => {
                stagedImages = stagedImages.filter(img => img.id !== image.id);
                updateImagePreviews();
            };
            
            wrapper.appendChild(imgEl);
            wrapper.appendChild(removeBtn);
            imagePreviewContainer.appendChild(wrapper);
        });
      }

      function clearStagedImages() {
          stagedImages = [];
          updateImagePreviews();
      }

      // --- API Call ---
      async function fetchAIResponse() {
        toggleInput(false);
        const assistantMsgContainer = createAssistantMessageContainer();
        let fullResponse = '';
        const errorPrefix = translate('error.prefix', 'Error: ');
        const apiConfig = chatConfig.api || {};
        const apiType = (apiConfig.type || 'ollama').toString().toLowerCase();

        const extractTextFromOpenAiDelta = (delta) => {
          if (!delta) return '';
          if (typeof delta === 'string') return delta;
          if (Array.isArray(delta)) {
            return delta.map(extractTextFromOpenAiDelta).join('');
          }
          if (typeof delta === 'object') {
            if (Array.isArray(delta.content)) {
              return delta.content.map((part) => {
                if (typeof part === 'string') return part;
                if (!part || typeof part !== 'object') return '';
                if (part.type === 'text' && typeof part.text === 'string') return part.text;
                if (part.type === 'output_text' && typeof part.text === 'string') return part.text;
                if (typeof part.text === 'string') return part.text;
                if (part.text) return extractTextFromOpenAiDelta(part.text);
                if (part.content) return extractTextFromOpenAiDelta(part.content);
                return '';
              }).join('');
            }
            if (typeof delta.text === 'string') return delta.text;
            if (Array.isArray(delta.text)) return delta.text.map(extractTextFromOpenAiDelta).join('');
            if (typeof delta.content === 'string') return delta.content;
            if (delta.delta) return extractTextFromOpenAiDelta(delta.delta);
            if (delta.message) return extractTextFromOpenAiDelta(delta.message);
            if (delta.content) return extractTextFromOpenAiDelta(delta.content);
          }
          return '';
        };

        const getChunkTextFromOpenApi = (parsed) => {
          if (!parsed || typeof parsed !== 'object') return '';
          let collected = '';
          if (Array.isArray(parsed.choices)) {
            for (const choice of parsed.choices) {
              if (choice.delta) collected += extractTextFromOpenAiDelta(choice.delta);
              else if (choice.message) collected += extractTextFromOpenAiDelta(choice.message);
            }
          }
          if (!collected && parsed.delta) collected += extractTextFromOpenAiDelta(parsed.delta);
          if (!collected && parsed.message) collected += extractTextFromOpenAiDelta(parsed.message);
          if (!collected && parsed.content) collected += extractTextFromOpenAiDelta(parsed.content);
          return collected;
        };

        const getChunkTextFromOllama = (parsed) => {
          if (!parsed || typeof parsed !== 'object') return '';
          if (parsed.message && parsed.message.content) return parsed.message.content;
          if (typeof parsed.content === 'string') return parsed.content;
          return '';
        };

        const buildOllamaMessages = (history) => history.map((msg) => {
          const payload = { role: msg.role, content: msg.content || '' };
          if (Array.isArray(msg.images) && msg.images.length > 0) {
            const imagePayload = msg.images
              .map((img) => {
                if (typeof img === 'string') return img;
                if (img && typeof img.base64Raw === 'string') return img.base64Raw;
                return '';
              })
              .filter(Boolean);
            if (imagePayload.length > 0) payload.images = imagePayload;
          }
          return payload;
        });

        const buildOpenApiMessages = (history) => history.map((msg) => {
          if (msg.role !== 'user') {
            return { role: msg.role, content: msg.content || '' };
          }
          const parts = [];
          const textContent = msg.content || '';
          if (textContent) {
            parts.push({ type: 'text', text: textContent });
          }
          if (Array.isArray(msg.images)) {
            for (const img of msg.images) {
              if (!img) continue;
              let base64Raw = '';
              let mimeType = '';
              if (typeof img === 'string') {
                base64Raw = img;
              } else {
                base64Raw = typeof img.base64Raw === 'string' ? img.base64Raw : '';
                mimeType = img.mimeType || extractMimeTypeFromDataUrl(img.base64Full);
              }
              if (!base64Raw) continue;
              const dataUrl = `data:${mimeType || IMAGE_MIME_FALLBACK};base64,${base64Raw}`;
              parts.push({ type: 'image_url', image_url: { url: dataUrl } });
            }
          }
          if (parts.length === 0) {
            return { role: 'user', content: '' };
          }
          if (parts.length === 1 && parts[0].type === 'text') {
            return { role: 'user', content: parts[0].text };
          }
          return { role: 'user', content: parts };
        });

        const resolveOpenApiUrl = (rawBaseUrl) => {
          const trimmed = (rawBaseUrl || '').trim();
          if (!trimmed) throw new Error('API base URL is not configured.');
          try {
            const parsed = new URL(trimmed);
            const lowerPath = parsed.pathname.toLowerCase();
            if (lowerPath.includes('/chat/completions')) {
              return parsed.toString();
            }
            if (/\/v\d+\/?$/.test(lowerPath)) {
              parsed.pathname = parsed.pathname.replace(/\/?$/, '') + '/chat/completions';
              return parsed.toString();
            }
            if (lowerPath === '/' || lowerPath === '') {
              parsed.pathname = parsed.pathname.replace(/\/?$/, '') + '/v1/chat/completions';
              return parsed.toString();
            }
            parsed.pathname = parsed.pathname.replace(/\/?$/, '') + '/chat/completions';
            return parsed.toString();
          } catch (err) {
            throw new Error('Invalid API base URL');
          }
        };

        const sanitizeOpenApiParams = (params) => {
          if (!params || typeof params !== 'object') return {};
          const sanitized = {};
          for (const [key, value] of Object.entries(params)) {
            if (value === null || typeof value === 'undefined') continue;
            if (key === 'context_window' || key === 'top_k' || key === 'min_p') continue;
            sanitized[key] = value;
          }
          return sanitized;
        };

        try {
          const { baseUrl = '', model = '', apiKey = '' } = apiConfig;
          if (!model) {
            throw new Error('Model is not configured.');
          }
          if (!baseUrl) {
            throw new Error('API base URL is not configured.');
          }

          const llmParams = chatConfig.llmParams || {};
          const headers = { 'Content-Type': 'application/json' };
          let url = '';
          let body = {};

          if (apiType === 'openapi') {
            url = resolveOpenApiUrl(baseUrl);
            if (apiKey) {
              if (/\.azure\./i.test(url)) {
                headers['api-key'] = apiKey;
              } else {
                headers['Authorization'] = `Bearer ${apiKey}`;
              }
            }
            body = Object.assign({
              model,
              messages: buildOpenApiMessages(conversationHistory),
              stream: true
            }, sanitizeOpenApiParams(llmParams));
          } else {
            url = new URL('/api/chat', baseUrl).toString();
            if (apiKey) {
              headers['Authorization'] = `Bearer ${apiKey}`;
            }
            body = {
              model,
              messages: buildOllamaMessages(conversationHistory),
              stream: true,
              options: llmParams
            };
          }

          try {
            console.log('ChatPage: sending API request to', url, 'type=', apiType);

            const msgs = Array.isArray(conversationHistory) ? conversationHistory : [];
            const messagesCount = msgs.length;
            const hasImages = msgs.some(m => Array.isArray(m.images) && m.images.length > 0);

            let lastPreview = '';
            try {
              const last = msgs.length ? msgs[msgs.length - 1] : null;
              if (last && last.content) lastPreview = String(last.content).slice(0, 120);
            } catch (e) { lastPreview = ''; }

            let totalImages = 0;
            let totalBase64Chars = 0;
            for (const m of msgs) {
              if (Array.isArray(m.images) && m.images.length > 0) {
                totalImages += m.images.length;
                for (const im of m.images) {
                  try {
                    if (typeof im === 'string') totalBase64Chars += im.length;
                    else if (im && typeof im.base64Raw === 'string') totalBase64Chars += im.base64Raw.length;
                  } catch (err) { }
                }
              }
            }
            const approxImageBytes = Math.round(totalBase64Chars * 0.75);

            let apiOrigin = '';
            try { apiOrigin = (new URL(url || baseUrl || '')).origin || baseUrl || ''; } catch (e) { apiOrigin = baseUrl || ''; }

            const summary = {
              messagesCount,
              hasImages,
              totalImages,
              approxImageBytes,
              lastPreview,
              api: { model: model || '', origin: apiOrigin, type: apiType }
            };

            console.log('ChatPage: payload summary', JSON.stringify(summary));
          } catch (e) { console.warn('ChatPage: payload summary logging failed', e); }

          const response = await fetch(url, {
            method: 'POST',
            headers,
            body: JSON.stringify(body)
          });

          if (!response.ok) {
            const errorText = await response.text();
            const errMsg = `API Error: ${response.status} ${response.statusText} - ${errorText}`;
            try { setStatus(errMsg, true); } catch (e) { }
            throw new Error(errMsg);
          }

          if (!response.body) {
            throw new Error('Empty response body.');
          }

          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let partialLine = '';
          let streamClosed = false;

          while (!streamClosed) {
            const { done, value } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value, { stream: true });
            const lines = (partialLine + chunk).split(/\r?\n/);
            partialLine = lines.pop() || '';

            for (const rawLine of lines) {
              const line = rawLine.trim();
              if (!line) continue;
              if (line.startsWith('event:')) continue;
              let dataLine = line;
              if (line.startsWith('data:')) {
                dataLine = line.slice(5).trim();
                if (!dataLine) continue;
                if (dataLine === '[DONE]') {
                  streamClosed = true;
                  break;
                }
              }
              try {
                const parsed = JSON.parse(dataLine);
                if (parsed.error || (parsed.message && parsed.message.error)) {
                  const errText = parsed.error || (parsed.message && parsed.message.error) || JSON.stringify(parsed);
                  try { setStatus(String(errText), true); } catch (e) { }
                  updateAssistantMessage(assistantMsgContainer, `${errorPrefix}${errText}`, true);
                  throw new Error(String(errText));
                }
                const chunkText = apiType === 'openapi'
                  ? getChunkTextFromOpenApi(parsed)
                  : getChunkTextFromOllama(parsed);

                if (chunkText) {
                  fullResponse += chunkText;
                  updateAssistantMessage(assistantMsgContainer, chunkText);
                }
              } catch (parseError) {
                try {
                  const lower = String(dataLine || line).toLowerCase();
                  if (lower.includes('error') || lower.includes('failed') || lower.includes('this model is missing data')) {
                    try { setStatus(String(dataLine || line), true); } catch (e) { }
                    updateAssistantMessage(assistantMsgContainer, `${errorPrefix}${dataLine || line}`, true);
                    throw new Error(String(dataLine || line));
                  }
                } catch (_) { }
                console.warn('Failed to parse stream line:', dataLine || line, parseError);
              }
            }

            if (streamClosed) break;
          }

          if (!streamClosed && partialLine.trim()) {
            try {
              const parsed = JSON.parse(partialLine.trim());
              if (parsed.error || (parsed.message && parsed.message.error)) {
                const errText = parsed.error || (parsed.message && parsed.message.error) || JSON.stringify(parsed);
                try { setStatus(String(errText), true); } catch (e) { }
                updateAssistantMessage(assistantMsgContainer, `${errorPrefix}${errText}`, true);
                throw new Error(String(errText));
              }
              const chunkText = apiType === 'openapi'
                ? getChunkTextFromOpenApi(parsed)
                : getChunkTextFromOllama(parsed);
              if (chunkText) {
                fullResponse += chunkText;
                updateAssistantMessage(assistantMsgContainer, chunkText);
              }
            } catch (_) { }
          }

          conversationHistory.push({ role: 'assistant', content: fullResponse });

        } catch (error) {
          console.error('Fetch error:', error);
          const errorMessage = `${errorPrefix}${error.message}`;
          updateAssistantMessage(assistantMsgContainer, errorMessage, true);
          setStatus(errorMessage, true);
          if (conversationHistory.length && conversationHistory[conversationHistory.length - 1].role === 'user') {
            conversationHistory.pop();
          }
          return;
        } finally {
          toggleInput(true);
          updateAssistantMessage(assistantMsgContainer, '', true);
        }
      }

      // Start the application
      initializeChat();

      // --- Image modal for zoom ---
      const imgModal = document.createElement('div');
      imgModal.style.position = 'fixed';
      imgModal.style.left = '0';
      imgModal.style.top = '0';
      imgModal.style.width = '100%';
      imgModal.style.height = '100%';
      imgModal.style.display = 'none';
      imgModal.style.alignItems = 'center';
      imgModal.style.justifyContent = 'center';
      imgModal.style.background = 'rgba(0,0,0,0.85)';
      imgModal.style.zIndex = '9999';
      imgModal.onclick = () => { imgModal.style.display = 'none'; imgModal.innerHTML = ''; };
      document.body.appendChild(imgModal);

      // Delegate click for images to open modal
      document.body.addEventListener('click', (e) => {
        const t = e.target;
        if (t && t.tagName === 'IMG' && t.closest('.message')) {
          const src = t.src;
          if (!src) return;
          imgModal.style.display = 'flex';
          const img = document.createElement('img');
          img.src = src;
          img.style.maxWidth = '90%';
          img.style.maxHeight = '90%';
          img.style.boxShadow = '0 4px 24px rgba(0,0,0,0.6)';
          imgModal.innerHTML = '';
          imgModal.appendChild(img);
        }
      });

  </script>
  <script src="./i18n-dom.js"></script>
  <script>
    // initialize DOM i18n helper using persisted locale when possible
    (async function(){
      if (!window.i18nDom || typeof window.i18nDom.init !== 'function') return;
      const docLang = (document.documentElement && document.documentElement.lang) ? document.documentElement.lang : 'en';
      try {
        if (window.localeAPI && typeof window.localeAPI.getLocale === 'function') {
          const persisted = await window.localeAPI.getLocale();
          await window.i18nDom.init(persisted || docLang || 'en');
          return;
        }
      } catch (e) {
        // ignore and fallback
      }
      await window.i18nDom.init(docLang || 'en');
    })();
  </script>
</body>

</html>